## Объектно ориентированное проектирование
### Основные принципы
* [SOLID](https://ru.wikipedia.org/wiki/SOLID)

Single responsibility, Open-closed, Liskov substitution, Interface segregation и Dependency inversion
* [DRY](https://ru.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself)

Don’t repeat yourself
### Общие замечания
Приложение необходимо проектировать (писать) так, что бы в него легко было вносить изменения.
Далее по тексту дано описание общих принципов проектирования кода, позволяющих добиться этой цели.
### Разграничение ответственности
#### Единичная ответственность (single responsibility)
Каждый класс и каждый метод должны иметь только одну ответственность (обязанность).
Как проверить - описание того, что делает класс (метод) должно поместиться в одном предложении без слов "и" "или".

#### Не использовать имена переменных экземпляра
Внутри классов не стоит использовать имена переменных экземпляра, а использовать методы, возвращающие значения переменных.

#### Не использовать примитивные типы данных
Вместо примитивных типов данных лучше использовать обертки - объекты представляющие данные.
Например, вместо массива, где каждому индексу соответствует свойство использовать структуру, свойства которой ссылаются на индексы.
```ruby
class Класс
  def метод
    good_struct = GoodStruct.new(arr)
    good_struct.метод
  end

  GoodStruct = Struct.new(arr) do
    def поле1
      arr[0]
    end
    def поле2
      arr[1]
    end
  end
end
```
### Изоляция связей
#### Инъекция связи
Вместо использования имени одного класса внутри других классов следует использовать абстракцию - переменную (или метод) в которой содержится внешний класс.
Сам внешний класс передается при инициировании класса как параметр.
```ruby
class Класс
  attr_reader :external_klass
  def initialize(external_klass)
    @external_klass = external_klass
  end

  def метод
    external_klass.method
  end
end
```
#### Изоляция создания экземпляра внешнего класса
Если енъекция класса не реализуема, то надо изолировать создание экземпляра внешнего класса.
По сути надо стараться сконцентрировать весь код использующий зависимость от внешнего класса в одном месте кода, так его легце найти и, при необходимости, откорректировать.
```ruby
class Класс
  attr_reader :external_klass
  def initialize(external_klass)
    @external_klass = external_klass
  end

  def external_klass
    @external_klass ||= ВнешнийКласс.new
  end
end
```
#### Изоляция внешних сообщений
Принцип тут тот же, что и при изоляции создания экземпляра внешнего класса - вызовы методо в внешних классов локализовать в отдельном месте кода (методах - обёртках).
```ruby
class Класс
  def метод
    оболочка.external_method
  end

  def оболочка
    external_klass.external_method
  end
end
```
#### Устранение зависимостей от порядка аргументов
Для этого можно использовать хэши (по сути используются именованые параметры).
```ruby
class Класс
  def initialize(хэш)
    @параметры = defaults.merge(хэш)
  end

  def defaults
    {параметр: 'значение по умолчанию'}
  end
end
```

> Если аргументы в используемом внешнем методе зависят от порядка их следования, то можно создать метод-обёртку, в котором уже использваоть для парамтеров хэш.

### Управление направлением зависимостей.
При проектировании следует добиваться того, что бы классы зависили от классвов (абстрактных), которые редко меняются.

### Поиск открытых интерфейсов
Определение сигналов, переадваемых между объектами.
Сигналы, посылаемые объекту, должны говорить ему что сделать, а не как.
### Упрощение контекста
У объектов должны быть простые контексты.
### [Закон Деметры](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD_%D0%94%D0%B5%D0%BC%D0%B5%D1%82%D1%80%D1%8B)
Закон Деметры (LoD) гласит - нельзя посылать сообщение одному объекту через другой объект, тип которого отличается от первого объекта (разговор возможен только с ближайшими соседями).
Дргугими слова - нельзя передавать сообщения по цепочке
```ruby
some_object1.some_object2.methdod
```
Не будет нарушением закона Деметра, если результат отправки сообщения в цепочке одно типа, например Enumerable
```ruby
some_hash.keys.each { |k| puts k}
```
### Литература
[Practical Object-Oriented Design in Ruby: An Agile Primer](https://www.oreilly.com/library/view/practical-object-oriented-design/9780132930895/)

> Название в переводе - Ruby. Объектно-ориентированное проектирование
