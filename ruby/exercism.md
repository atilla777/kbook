##### [Главная страница](../index.md)
##### [Ruby](index.md)
## По отработке задач в [Exercism](https:\\exercism.io)
#### Использование методов с "говорящими" названиями
На примере проверки пустых или нулевых значений
Плохо
```ruby
объект ==  0
```
Хорошо
```ruby
объект.zero?
```
Плохо
```ruby
объект ==  ''
```
Хорошо
```ruby
объект.empty?
```
#### Слипание массивов
```ruby
массив1 = [1, 2]
массив2 = ['a','b']
массив1.zip(массив2) # [[1, 'a'], [2, 'b' ]]
```
#### Разница времени в секундах
```ruby
Time.new(1977, 18, 4, 5, 5,5) - Time.new(1977, 18, 4, 5, 5,5)
```
#### Удаление из строки/замена в строк символов
```ruby
строка.tr('a-z', '')
строка.tr('abc', '')
строка.tr('0-9', '')
```
#### Замена символов в строке
```ruby
'AAABBBCCC'.tr('ABC', '123') # '111222333'
```
#### Замена подстрок в строке (в примере - вырезание символов пунктуации):
```ruby
'слово слово слово'.gsub([[:punct:]])
```
#### Массив слов из строки
```ruby
'слово слово слово'.scan(/\b[\w]+\b/)
```
#### Объект типа Method
Для передачи метода в качестве параметра функции или блока создается обхект класса Method.

Пример - приемник метода является указанный объект, параметром метода поочередно будет каждый элемент массива
```ruby
массив.map(&объект.method(:метод))
объект = -> (элемент) { метод(элемент)}
```
#### Хэш из сгруппированных одинаковых элементов массива
Под одним ключем хэша группируются элементы с одинаковым результатом вычисления блока.

Ключ в таком хэше равен результату вычисления.
```ruby
массив.group_by { |элемент| элемент}
```
Или, с учетом того, что метод #itself возвращает сам объект (приемник этого метода)
```ruby
массив.group_by(&:itself)
```
#### Преобразование значений хэша
```ruby
хэш.transform_values { |элемент| элемент.count}
```
или
```ruby
хэш.transform_values(&:count)
```
#### Проверка попадания в диапазон
```ruby
(диапазон).cover?(значение)
```
#### Использование объекта класса Lazy для работы с бесконечнсостями
Ряд функций Enumerable (select, map и т.п.) можно преобразовать в объект класса Lazy.

Вычисления в Lazy объекте не выполняются сразу от первого метода в цепочке, а производятся с учетом всего выражения в цепочке.
```ruby
(2..Float::INFINITY).lazy
                    .select { |n| условие c n }
                    .first(количество)
                    .last
```
Где #first(количество) - возращает указанное количество первых элементов
#### Значения по умолчанию для хэша
Если происходит обращение к хэшу, созданному с помощью Hash.new с параметром в виде значения или блока, посредством ключа, для которого нет значений в хэше, то вместо nil будет возращаться определенное в параметре или блоке значение.
```ruby
Hash.new(значение)
```
или
```ruby
Hash.new {|hash, key| hash[:key] = значение}
```
#### Index в map
```ruby
['a', 'b', 'c'].map.each_with_index {|element, index| код}
```
#### Reduce и inject
Методы #reduce и #inject псевдонимы, каждый из которых испльзуется в зависимости от текущего контекста кода.

Если аргумент блок, то используется #inject.

Если аргумент символ, то применяется #reduce.

Если необходимо только порссумировать все элементы, то вместо #inject или #reduce лучше использовать #sum.
Пример - вычисление факториала
```ruby
def fact(number)
  (1..number).reduce(:*)
end
```
#### Хвостовая рекурсия
Рекурсивный вызов должен быть последним выражением в рекурсивной функции.

При использовании хвостовой рекурсии вместо помещения текущей функции в стек и переходу к выполнению новой функции, выполнение функции начинается сначала но с новыми параметрами, взятыми из последнего выражения функции (выражение с рекурсивным вызовом).

Хвостовая рекурсия должна быть включена в компиляторе, а также а рекурсивный метод должен быть определен на этапе компиляции
```ruby
RubyVM::InstructionSequence.compile_option = {
  :tailcall_optimization => true,
  :trace_instruction => false
}

eval <<~END
  def for(number, factor = 2, accum = [])
     #…
    def for(number, factor, accum)
  end
END
```

