## Миграции
### Создание миграций
Миграции размещаются в **./db/migrations**.

Порядок выполнения миграций определяется временем ее создания в имени файла миграции.

Информация о текущей версии миграции сохраняется в базе в таблице schema_migrations и в файле db**./db/shcema.rb**.

#### Генерация миграции, создающей таблицу БД
```bash
railg g migration CreateТаблицаs поле1 модель1:references модель2:belongs_to поле2:тип поле3:тип:index
```
Если тип поля не указан, тип будет **:text**.

Для добавления поля в индекс используется директива **index**.

Для создания поля связывающего создаваемую таблицу с другой (связь одно ко многому) указывается директива 

**модель1:references** (или belongs_to в модель2:references), такая директива аналогична **модель_id:integer:index** 
> В Rails 5x индекс создается если в миграции установлено foreign_key: true, то есть index_true: true не требуется)

#### Создание таблицы, связывающей две таблицы (многое ко многому)
```bash
railg g migration CreateJoinTableТаблица1sТаблица2s модель1 модель2
```
Миграции для создания таблиц также создаются при генерации модели или scaffold. Синтаксис определяющий параметры соответствующих полей таблицы (index, refernces и т.п.) аналогичен описанному выше.

#### Добавить поле в таблицу
```bash
railg g migration AddПолеToТаблицаs поле:тип
```
или с добавлением поля в индекс
```bash
railg g migration AddПолеToТаблицаs поле:тип:index
```
#### Удалить поле из таблицы
```bash
railg g migration RemoveПолеFromТаблицаs поле:тип
```
#### Добавить индекс к столбцу (тип поля - string)
```
rails g migration AddIndexToUsers name:string:index
```
#### Добавить миграцию добавляющую поле связывающее таблицу (в примере - organizations) саму с собою (родитель - потомок)
```bash
rails g migration AddOrganizationsToOrganizations parent:belongs_to
```
В сгенерированной миграции
```ruby
class AddOrganizationsToOrganizations < ActiveRecord::Migration[5.1]
  def change
    add_reference :organizations, :parent, table: :organizations, index: true
    add_foreign_key :organizations, :organizations, column: :parent_id
  end
end
```
#### Добавить расширение в postgresql
Создать пустую миграцию
```bash
rails g migration ИмяМиграции
```
В файл миграции добавляем соответствующую директиву
```bash
def change
  enable_extension :расширение
end
```
Внутри файла миграции в методе change можно использовать предопределённые методы (create_table, add_index и т.д.) с помощью которых Rails может как поднять миграцию, так и откатить ее.

Если предопределенных методов недостаточно, можно использовать чистый SQL, помещаемый в метод reversible (внутри которого используются методы up и down) или как раньше в методы up и down.
#### Создать произвольную SQL миграцию
Cоздать пустую миграцию
```bash
rails g migration ИмяМиграции
```
Внести изменения в файле миграции
```ruby
def change
  reversible do |dir|
    dir.up do
      execute 'SQL код миграции'
    end
  end
  reversible do |dir|
    dir.down do
      execute 'SQL код отмены миграции'
    end
  end
end
```
При этом произвольный код SQL выполняется с помощью метода **execute**.

Также надо учитывать, что при использовании чистого SQL в миграции, вместо ruby файла схемы (файл из которого создается база для нового приложения) необходимо использовать SQL файл схемы (см. файл **./config/application.rb**).
### Выполнение и отмена миграций
#### Для просмотра всех вариантов использования миграций удобно использовать команду
```bash
rake --tasks
```
#### Для того, что бы сгенерировать собственную задачу
```bash
rails g task пространство имя
```
#### Для указания среды для которой выполняются миграции используется переменная RELS_ENV
```bash
rails db:migrate RAILS_ENV=test
```
Каждое выполнение миграции меняет схему **./db/schema.rb** (менять файл вручную не следует), которая используется при разворачивании базы данных приложения при его установке (при выполнении rails db:load).

Если миграции содержат специфический для СУБД команды SQL, которые не могут выполнены с помощью DSL миграций, указав в файле **./config/application.rb** можно сказать приложению вместо использования **schema.rb** с кодом ruby, поддерживать файл схемы в формате SQL – **structure.sql**
```
config.active_record.schema_format :sql
```
#### Исполнить неотработанные миграции и обновить схему
```bash
rails db:migrate
```
#### Выполнить/отменить только указанную миграцию
```bash
rails db:migrate:up VERSION=версия
```
или
```
rails db:migrate:down VERSION=версия
```
#### Отменить все миграции
```bash
rails db:migrate VERSION=0
```
#### Откатить все миграции до версии (можно перейти как вверх, так и вниз по версиям)
```bash
rails db:migrate VERSION=версия
```
#### Текущая версия миграции
```bash
rails db:version
```
#### Отменить последнюю миграцию
```bash
rails db:rollback
```
#### Отменить указанное количество последних миграций
```bash
rails db:rollback STEP=количество
```
#### Заполнить базу начальными значениями (выполнить файл **./db/seeds.rb**)
```bash
rails db:seed
```
```
rails db:purge
```
#### Удаление базы
```
rails db:drop
```
#### Отмена всех миграций и пересоздание схемы (по порядку исполняя файлы миграций, а не из файла схемы)
```bash
rails db:drop
rails db:migrate
```
#### Отмена всех миграций и создание базы по информации файла **./db/schema.rb**
```bash
rails db:reset
```
#### Создание базы из схемы и выполнение **rails db:seed** (подходит для развертывания приложения)
```bash
rails db:setup
```
#### Создание базы из схемы
```bash
rails db:load
```
Создать тестовую базу из схемы (требуется для выполнения тестов **srspec**)
```bash
rails db:test:load
```
> До версии Rails 4.1 использовалась команда **rake db:test:prepare**, которая проверяла имеются ли не выполненные миграции и после этого загружала схему (с rails 4.1 изменения схемы отслеживаются автоматически)
