##### [Главная страница](../index.md)
##### [DevOps](index.md)
## [Docker](https://www.docker.com/)
### Установка
Согласно официальной [документации](https://docs.docker.com/install/linux/docker-ee/ubuntu/)
### Основные понятия
Инфраструктура docker реализуется за счет
* cgroups - распределение ресурсов (процессор, память)
* namespaces - пространства имен (изоляция пространств имен процессов, хостов, пользователей, изоляция сети)
* файловая система UnionFS - файловые системы накладываются друг на друга с перекрытием.
#### Хост
Хост - это компьютер на котором работает docker демон
#### Демон **docker**
Демон управляет образами и контейнерами (создание, запуск и т.п.).
Демон запускается командой **docker daemon**.
Запуск демона docker (systemd)
```bash
sudo systemctl start docker
```
#### Клиент docker
Клиент управляет демоном по протоколу HTTP (команда docker).
По каждой команде docker можно получить справку
```bash
docker <команда> --help
```
#### Image (образ)
Образ - это стек слоёв для чтения (части файловой системы UnionFS , доступные только для чтения).

Каждый слой - это результат выполнения команды в Dockerfile. 
Образы хранятся в реестрах образов, например [Docker hub](https://hub.docker.com/).
Локально скаченные из реестра образы хранятся в **/var/lib/docker**
#### Container (контейнер)
Контейнер - это экземпляр, развернутый из образа (образ плюс слой UnionFS доступный для записи).
#### Запущенный контейнер (экземпляр)
Запущенный контейнер - это контейнер с пространством процессов, портов и т.п.
#### Dockerfile
Dockerfile - это файл в котором описано, как строится образ.
По умолчанию при построении образа (docker build) берется Dockerfile из текущей директории.
#### Build context (контекст построения)
Buid context - это текущая рабочая папка на хосте относительно которой будут выполняться команды в Dockerfile.
В рабочей папке должны находится только файлы, необходимые для построения образа (build context передается демону docker и его большой размер замедлит построение образа).
### Работа с образами
#### Скачать образ
```bash
docker pull <репозиторий>:<образ>
```
Пример - получение образа последней (last) версии Ubuntu
```bash
docker pull ubuntu:last
```
#### Создание образа (последовательность команд **run** - создание и запуск контейнера и **commit** - фиксирование изменений как слоя только на запись для каждой команды из Dockerfile)
Для создания образа необходимо создать Dockerfile
```dockerfile
FROM <базовый образ>
VOLUME </путь к папке>
WORKDIR </абсоютный путь к директории в контейнере, которая будет текущим каталогом для всех последующих команд>
COPY <файл копируемый с хоста> </полный путь к конечному файлу в контейнере>
RUN <команды (через && \), добавляющие необходимые изменения в базовый образ>
ADD <файл копируемый с хоста (может быть tar архивом) или с URL> </полный путь к конечному файлу в контейнере>
EXPOSE <объявление используемых портов>
CMD <команда, запускающая первый процесс>
```
Команду COPY, с учетом предвартельно выполнненой команды WORKDIR, можно испльзовать так
COPY . .
То есть все из каталога с файлом Dockerfile копируется в текущую диреторию в контейнере (текущая это та, в ктороую на перевела команда WORKDIR)

Вместо (а можно и совместно) CMD можно указать путь к скрипту в контейнере (ENTRYPOINT), который будет запускать первый процесс контейнера.
CMD запускает команды через оболочку (shell), а ENTRYPOINT без оболочки

Команда WORKDIR создает папку, если её ещё нет.

Команда VOLUME создаст том на хосте и ппримонтирует его в указанную папку.
Также имя монируемого тома и папку в которую он монтируется на контейнере можно указать при запуске контейнера командой docker run (см. ниже).

Непосредственно создание образа из Dockerfile и присвоение ему тега (-t)
```bash
cd <папка с Dockerfile>
docker build -t <репозиторий/имя>
docker commit
```
#### Список образов
```bash
docker images -aq
```
Опция **-a** позволяет увидеть все образы (не только базовые, полученные из репозитория), а опция **-q** оставляет в выводе только идентификаторы образов (это удобно использовать для передачи вывода списка образов в другие команды docker, например в команду адления образов).

Атрибуты образа
* ID - уникальный на локальном хосте идентификатор образа
* Tag - «человеческое» имя образа
* Репозиторий - имя репозитория из которого получен образ

#### Удалить образ
```bash
docker rmi <образ>
```
> Опция **-f** позволяет удалить образ принудительно (например, когда он требуется для контейнеров)

### Работа с контейнерами
#### Список контейнеров
```bash
docker container ls -aq
```
Опция **-a** позволяет увидеть все контейнерв (не только запущенные), опция **-q** оставляет в выводе только идентификаторы контейнеров (это удобно использовать для передачи вывода списка образов в другие команды docker, например в команду адления контейнеров).

#### Создание контейнера (добавление к изображению слоя доступного для записи)
```bash
docker сreate <образ>
```
#### Запуск контейнера (процессы контейнера появляются в ОЗУ)
```bash
docker start <ID контейнера>
```
#### Создание и запуск контейнера (команды **create** и **start**)
```bash
docker run <образ>
```

> При запуске образа можно последним параметром указать команду (например, **bash**), которая запустится после запуска контейнера (это будет первый процесс контейнера с ID 0) и подключиться к терминалу контейнера (опция **-ti**)
```bash
docker run -ti ubuntu bash
```
#### Запуск команды внутри запущенного контейнера
```bash
docker exec <ID контейнера> <команда>
```
#### Запуск контейнера в фоновом режиме (-d)
```bash
docker run <образ> -d
```
#### Создание и запуск контейнера с мапингом портов
```bash
docker run -p <порт на хосте>:<порт в контейнере> <образ>
```
> Порт в контейнере должен быть привязан к адресу 0.0.0.0, а не к localhost

#### Создание и запуск контейнера с внешним томом
```bash
docker --mount type=volume,source=<имя тома>,destination=/<путь к папке в контейнере> <образ>
````
где type=volume,source=<имя тома>,destination=/<путь к папке в контейнере> это параметр опции --mount

или через опцию -v без указаняи имя тома (устаревший синтаксис)
```bash
docker run -v </папка на хосте>:</папка в контейнере - точка монтирования> <образ>
```
или через опцию -v с указанием имени тома
```bash
docker run -v <том>:</папка в контейнере - точка монтирования> <образ>
```
или через опцию -v без указанием имени тома или папки на хосте (анонимный том, место размещения которого определит dcoker)
```bash
docker run -v /папка в контейнере - точка монтирования> <образ>
```
> Данные на томе будут сохранятся в файловой системе хоста, а не контейнера и при удалении контейнера данные не прорадут.

По умолчанию место хранение томов - **/var/lib/docker/volumes/**

Список томов
```bash
docker volume ls
```
#### Список контейнеров
```bash
docker ps
```
> Опция **-a** позволяет увидеть все контейнеры (не только запущенные)

Атрибуты контейнера
* ID - уникальный на локальном хосте идентификатор контейнера (новый при каждом запуске)
* Tag - «человеческое» имя образа (можно установить опцией **--name** при запуске контейнера)

#### Информация о контейнере
```bash
docker inspect <ID контейнера>
```
#### Информация о дисковом пространстве, используемом docker
```bash
docker system df
```
#### Удалить контейнер (по сути - удаление слоя для записи)
```bash
docker rm <контейнер>
```
Контейнер можно удалить (--rm) после окончания его работы
```bash
docker run --rm <образ>
```
Передача в команду docker вывода другой команды docker (или команды обалочки) как значения параметра - $()
```bash
docker rmi $(docker images -f "dangling=true" -q)
```
где dangling - это образ (обособленный), не связанный ни с каким образом, имеющим тег и не являющийся промежуточным образом (слоем) для других образов (то есть такие образы можно удялять, очищая место на диске).
#### Остановить (SIG TERM) контейнер
```bash
docker stop <ID контейнера>
```
#### Остановить грубо (SIG KILL) контейнер
```bash
docker kill <ID контейнера>
```
### Работа с реестром (репозииторием)
#### Скачать образ
```bash
docker pull <репозиторий>/<тег>:<версия>
```
> по умолчанию версия - **latest** (последняя)

### Кэширование
Команды COPY, ADD, RUN добавляют слои и при этом жобавляемые ими данные могут изменять образ от запуска к запуску (например, результат выполнения RUN git clone, будет разгным, если код в git репазитории изменяется).
Добавляемые указанными выше командами в образ файлы сохраняются в кэше.
Если при выполнеии этих опираций добавляемые ими файлы, идентичны тем, что уже есть в кэше (наполнен предудщими выполнениями), то используются данные кэша.
Таким образом образ собирается быстрее.
Если нак какой то команде каш применен не будет (есть изменения, относительно предудщей версии), то результаты всех последующих команд уже не берутся из каша.
Отсюда рекомендация - выше в Docjkerfile надо размещать команды, при выполнеии которых реже будет изменяться содержимое образа (и соответсвенно кэша).
Например, выше следует помещать добавление библиотек (пакетов, зависимостей) кода, а ниже сам исходный код.
Пример неоптимального использования кэша (если исходный код изменился,то зависимости тоже будут скачены заново, так как операция скачивания идет после операции копирования исходного кода)
```
COPY requirments.txt .
COPY server.py
RUN pip install -r requirments.txt
```
Пример оптимального использотавния кэша (сначало получаем список зависимостей и устанавливаем их, затем получаем исходный код)
```
COPY requirments.txt .
RUN pip install -r requirments.txt
COPY server.py
```
### Multistaging
### Docker compose
#### Установка
```bash
sudo apt-get install docker-compose
```
#### Разворачивание контейнеров из файла docker-compose.yml
```bash
sudo docker-compose up
```
### Ссылки
* Docker в картинках - [оригинал](http://merrigrove.blogspot.com/2015/10/visualizing-docker-containers-and-images.html), [перевод](https://habr.com/post/272145/)
